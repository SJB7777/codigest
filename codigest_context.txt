
[SYSTEM: CODIGEST - INITIAL CONTEXT]
You are an expert AI developer. I am providing the full context of a project named "codigest".
Please digest this structure and code to build your internal mental model.

<project_root>
codigest
</project_root>

<project_structure>
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .python-version
â”œâ”€â”€ .ruff_cache
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ 0.14.8
â”‚   â”‚   â””â”€â”€ 12445044848939849648
â”‚   â””â”€â”€ CACHEDIR.TAG
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ codigest
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ actions.py
â”‚       â”œâ”€â”€ cli.py
â”‚       â”œâ”€â”€ config.py
â”‚       â”œâ”€â”€ config_manager.py
â”‚       â”œâ”€â”€ core.py
â”‚       â”œâ”€â”€ git_ops.py
â”‚       â”œâ”€â”€ interactive.py
â”‚       â””â”€â”€ prompts.py
â””â”€â”€ uv.lock
</project_structure>

<source_code>
<file path=".gitignore">

</file>

<file path=".ruff_cache/.gitignore">
# Automatically created by ruff.
*

</file>

<file path="pyproject.toml">
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "codigest"
version = "0.1.4"
description = "Digest your codebase for LLM context with Vibe Coding flow."
readme = "README.md"
requires-python = ">=3.14"
dependencies = [
    "pathspec",
    "platformdirs",
    "prompt-toolkit",
    "pyperclip",
]

[project.scripts]
codigest = "codigest.cli:main"

[dependency-groups]
dev = [
    "ruff",
]

</file>

<file path="README.md">

</file>

<file path="src/codigest/__init__.py">

</file>

<file path="src/codigest/actions.py">
import pyperclip
from pathlib import Path
from typing import List, Optional
from .core import ProjectScanner, ScanLimitError
from .git_ops import get_git_diff, is_git_repo
from .prompts import INITIAL_PROMPT_TEMPLATE, UPDATE_PROMPT_TEMPLATE

class DigestActions:
    def __init__(self, root_path: Path):
        self.root_path = root_path.resolve()

    def scan(self, target_paths: Optional[List[Path]] = None) -> str:
        """ì „ì²´ ìŠ¤ìº” (ì•ˆì „ ì¥ì¹˜ í¬í•¨)"""
        try:
            scanner = ProjectScanner(self.root_path)
            
            # 1. íŠ¸ë¦¬ ìƒì„±
            tree_str = scanner.generate_tree()
            
            # 2. íŒŒì¼ ìŠ¤ìº” (ì—¬ê¸°ì„œ ì œí•œ ê±¸ë¦¼)
            file_contents = []
            
            if target_paths:
                # íŠ¹ì • ê²½ë¡œë§Œ ìŠ¤ìº”í•  ë•ŒëŠ” ì „ì²´ ìŠ¤ìº” ëŒ€ì‹  íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê±°ë‚˜,
                # ì „ì²´ ìŠ¤ìº” í›„ í•„í„°ë§ (êµ¬í˜„ í¸ì˜ìƒ í•„í„°ë§ ë°©ì‹ ìœ ì§€í•˜ë˜, ì „ì²´ ìŠ¤ìº” ì‹œ ì•ˆì „ì¥ì¹˜ ì‘ë™)
                scanner.scan()
                paths_to_scan = []
                # ... (í•„í„°ë§ ë¡œì§) ...
                # (ì´ì „ ì½”ë“œì™€ ë™ì¼, ìƒëµ)
                # ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ì „ì²´ scan() í˜¸ì¶œë§Œ ë³´ì—¬ë“œë¦¼
                pass 
                # ì‹¤ì œ êµ¬í˜„ë¶€:
                scan_result = scanner.scan() # ì—¬ê¸°ì„œ ì˜ˆì™¸ ë°œìƒ ê°€ëŠ¥
                paths_to_scan = []
                for p in target_paths:
                     if p.is_dir():
                         paths_to_scan.extend([f for f in scan_result if str(f).startswith(str(p))])
                     else:
                         paths_to_scan.append(p)
                paths_to_scan = sorted(list(set(paths_to_scan)))

            else:
                # ì „ì²´ ìŠ¤ìº”
                paths_to_scan = scanner.scan()

            # 3. ë‚´ìš© ì½ê¸°
            for file_path in paths_to_scan:
                try:
                    rel_path = file_path.relative_to(self.root_path).as_posix()
                except ValueError:
                    rel_path = file_path.name
                
                try:
                    text = file_path.read_text(encoding="utf-8")
                    file_contents.append(f'<file path="{rel_path}">\n{text}\n</file>')
                except Exception: pass

            return INITIAL_PROMPT_TEMPLATE.format(
                root_name=self.root_path.name,
                tree_structure=tree_str,
                content="\n\n".join(file_contents)
            )

        except ScanLimitError as e:
            return f"âŒ Safety Stop: {e}\n   To fix: Add a .gitignore file or scan specific folders."
        except Exception as e:
            return f"âŒ Unexpected Error: {e}"

    def diff(self) -> str:
        """Git Diff ì¶”ì¶œ"""
        if not is_git_repo(self.root_path):
            return "âŒ Error: Not a git repository."
        
        diff = get_git_diff(self.root_path)
        if not diff.strip():
            return "âœ¨ Clean working tree (No changes)."
            
        return UPDATE_PROMPT_TEMPLATE.format(diff_content=diff)

    def copy_to_clipboard(self, content: str) -> bool:
        try:
            pyperclip.copy(content)
            return True
        except Exception:
            return False

    def save_to_file(self, content: str, filename: str = "codigest_context.txt") -> Path:
        out_path = self.root_path / filename
        out_path.write_text(content, encoding="utf-8")
        return out_path
</file>

<file path="src/codigest/cli.py">
import argparse
import sys
from pathlib import Path
from .actions import DigestActions
from .interactive import InteractiveShell

def main():
    parser = argparse.ArgumentParser(description="Codigest: CLI Code Context Generator")
    parser.add_argument("path", nargs="?", help="Target path (file or dir)")
    parser.add_argument("-d", "--diff", action="store_true", help="Get git diff only")
    
    args = parser.parse_args()

    if args.path:
        target_path = Path(args.path).resolve()
    else:

        target_path = Path.cwd()

    if target_path.is_file():
        root = target_path.parent
        initial_targets = [target_path]
    else:
        root = target_path
        initial_targets = None

    if not root.exists():
        print(f"âŒ Path not found: {root}")
        sys.exit(1)

    is_headless = args.diff or (args.path is not None)

    if is_headless:
        actions = DigestActions(root)
        
        if args.diff:
            print(f"âš¡ Fetching diff for {root.name}...")
            content = actions.diff()
        else:
            print(f"âš¡ Scanning {root.name}...")
            content = actions.scan(initial_targets)

        if content.startswith("âŒ") or content.startswith("âœ¨"):
            print(content)
        else:
            actions.save_to_file(content)
            if actions.copy_to_clipboard(content):
                print(f"âœ… Copied to clipboard ({len(content)} chars)")
            else:
                print(content)
    else:
        shell = InteractiveShell(root)
        shell.start()

if __name__ == "__main__":
    main()
</file>

<file path="src/codigest/config.py">
"""
Configuration constants for codeinspector.
"""

# íŒŒì¼ í™•ì¥ì í•„í„° (ë¶„ì„ ëŒ€ìƒ)
TARGET_EXTENSIONS: set[str] = {
    # Python
    ".py", ".pyi",
    # Web / JS
    ".ts", ".tsx", ".js", ".jsx", ".json",
    ".css", ".scss", ".html",
    # Config / Docs
    ".md", ".yaml", ".yml", ".toml", ".xml",
    ".gitignore", ".dockerignore", "Dockerfile"
}

# ê¸°ë³¸ì ìœ¼ë¡œ ë¬´ì‹œí•  ë””ë ‰í† ë¦¬ ë° íŒ¨í„´
DEFAULT_IGNORE_PATTERNS: list[str] = [
    ".git/",
    ".venv/", "venv/", "env/",
    "__pycache__/",
    "node_modules/",
    "dist/", "build/", "wheels/",
    ".idea/", ".vscode/", ".mypy_cache/",
    "*.pyc", "*.DS_Store", "*.egg-info"
]
</file>

<file path="src/codigest/config_manager.py">
import json
from pathlib import Path
from typing import Optional
from platformdirs import user_config_dir

APP_NAME = "codigest"

class ConfigManager:
    def __init__(self):
        self.config_dir = Path(user_config_dir(APP_NAME))
        self.config_file = self.config_dir / "config.json"
        
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.config = self._load_config()

    def _load_config(self) -> dict:
        if not self.config_file.exists():
            return {}
        try:
            return json.loads(self.config_file.read_text(encoding='utf-8'))
        except Exception:
            return {}

    def save_config(self):
        try:
            self.config_file.write_text(json.dumps(self.config, indent=2), encoding='utf-8')
        except Exception as e:
            print(f"âš ï¸ Failed to save config: {e}")

    def get_last_project_root(self) -> Optional[str]:
        return self.config.get("last_project_root")

    def set_last_project_root(self, path: str):
        self.config["last_project_root"] = str(path)
        self.save_config()
</file>

<file path="src/codigest/core.py">
from pathlib import Path
from typing import List
import pathspec
from .config import DEFAULT_IGNORE_PATTERNS, TARGET_EXTENSIONS

class ScanLimitError(Exception):
    pass

class ProjectScanner:
    def __init__(self, root_path: Path):
        self.root_path = root_path
        self.gitignore_spec = self._load_gitignore()

    def _load_gitignore(self) -> pathspec.PathSpec:
        patterns = list(DEFAULT_IGNORE_PATTERNS)
        gitignore = self.root_path / ".gitignore"
        if gitignore.exists():
            try:
                with open(gitignore, "r", encoding="utf-8") as f:
                    patterns.extend(f.read().splitlines())
            except Exception: pass
        return pathspec.PathSpec.from_lines("gitwildmatch", patterns)

    def is_ignored(self, path: Path) -> bool:
        try:
            rel = path.relative_to(self.root_path).as_posix()
        except ValueError: return False
        if path.is_dir(): rel += "/"
        return self.gitignore_spec.match_file(rel)

    # [MODIFIED] max_files íŒŒë¼ë¯¸í„° ì¶”ê°€ (ê¸°ë³¸ê°’ 10,000ê°œ)
    def scan(self, max_files: int = 10000) -> List[Path]:
        valid_files = []
        dirs_stack = [self.root_path]
        
        while dirs_stack:
            # ì•ˆì „ ì¥ì¹˜: ë„ˆë¬´ ì˜¤ë˜ ê±¸ë¦¬ê±°ë‚˜ íŒŒì¼ì´ ë§ìœ¼ë©´ ì¤‘ë‹¨
            if len(valid_files) > max_files:
                raise ScanLimitError(f"Too many files (> {max_files}). Missing .gitignore?")

            try:
                current = dirs_stack.pop()
                items = sorted(current.iterdir(), key=lambda x: x.name)
            except PermissionError: continue

            for item in items:
                if self.is_ignored(item): continue
                
                if item.is_dir():
                    dirs_stack.append(item)
                elif item.is_file():
                    if item.suffix.lower() in TARGET_EXTENSIONS or item.name in {".gitignore", "Dockerfile", "pyproject.toml"}:
                        valid_files.append(item)
        
        return sorted(valid_files)

    def generate_tree(self) -> str:
        # íŠ¸ë¦¬ ìƒì„±ì€ ì‹œê°ì  ìš”ì†Œì´ë¯€ë¡œ ì œí•œì„ ë‘ê±°ë‚˜, ê¹Šì´ ì œí•œì„ ë‘ëŠ” ê²ƒì´ ì¢‹ìŒ
        # ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ ê¸°ì¡´ ìœ ì§€í•˜ë˜, ë„ˆë¬´ ê¹Šì€ ê¹Šì´ëŠ” ìë¥´ëŠ” ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
        lines = []
        def _walk(path, prefix="", depth=0):
            if depth > 10: return # [NEW] ë„ˆë¬´ ê¹Šì€ íŠ¸ë¦¬ëŠ” ìƒëµ
            try: items = sorted(path.iterdir(), key=lambda x: x.name)
            except PermissionError: return
            
            filtered = [i for i in items if not self.is_ignored(i)]
            count = len(filtered)
            # ë„ˆë¬´ ë§ì€ íŒŒì¼ì´ í•œ í´ë”ì— ìˆìœ¼ë©´ ìƒëµ í‘œì‹œ
            if count > 50:
                filtered = filtered[:50]
                lines.append(f"{prefix}â””â”€â”€ ... ({count-50} more files)")
            
            for i, item in enumerate(filtered):
                is_last = (i == count - 1)
                connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
                lines.append(f"{prefix}{connector}{item.name}")
                if item.is_dir():
                    _walk(item, prefix + ("    " if is_last else "â”‚   "), depth + 1)
        
        _walk(self.root_path)
        return "\n".join(lines)
</file>

<file path="src/codigest/git_ops.py">
import subprocess
from pathlib import Path
from .config import TARGET_EXTENSIONS

def is_git_repo(root_path: Path) -> bool:
    return (root_path / ".git").exists()

def get_git_diff(root_path: Path) -> str:
    """
    ì†ŒìŠ¤ ì½”ë“œ íŒŒì¼ì— ëŒ€í•´ì„œë§Œ Git Diff ë° Untracked íŒŒì¼ ë‚´ìš©ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
    """
    try:
        # 1. ë³€ê²½ëœ íŒŒì¼ (Modified/Staged)
        diff_output = subprocess.check_output(
            ["git", "diff", "HEAD"], 
            cwd=root_path, 
            text=True, 
            encoding='utf-8',
            stderr=subprocess.DEVNULL 
        )
        
        # 2. ìƒˆë¡œ ìƒì„±ëœ íŒŒì¼ (Untracked)
        untracked_files = subprocess.check_output(
            ["git", "ls-files", "--others", "--exclude-standard"],
            cwd=root_path,
            text=True,
            encoding='utf-8',
            stderr=subprocess.DEVNULL
        ).splitlines()
        
        full_output = diff_output
        
        if untracked_files:
            new_files_content = ""
            has_new_files = False
            
            for f in untracked_files:
                file_path = root_path / f
                
                # íŒŒì¼ì´ ì•„ë‹ˆê±°ë‚˜ í—ˆìš©ëœ í™•ì¥ìê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µ
                if not file_path.is_file():
                    continue
                
                is_valid_ext = file_path.suffix.lower() in TARGET_EXTENSIONS
                is_config_file = file_path.name in {".gitignore", "Dockerfile", "Makefile", "pyproject.toml"}
                
                if not (is_valid_ext or is_config_file):
                    continue

                try:
                    content = file_path.read_text(encoding='utf-8')
                    new_files_content += f"diff --git a/{f} b/{f}\n"
                    new_files_content += "new file mode 100644\n"
                    new_files_content += f"--- /dev/null\n+++ b/{f}\n@@ -0,0 +1,{len(content.splitlines())} @@\n{content}\n"
                    has_new_files = True
                except (UnicodeDecodeError, Exception):
                    pass # ë°”ì´ë„ˆë¦¬ë‚˜ ì—ëŸ¬ ë°œìƒ ì‹œ ë¬´ì‹œ

            if has_new_files:
                full_output += "\n# Untracked (New) Source Files:\n" + new_files_content

        return full_output
    except subprocess.CalledProcessError:
        return "Error: Failed to run git diff."
</file>

<file path="src/codigest/interactive.py">
import sys
import os
import shlex
import subprocess
from pathlib import Path
from prompt_toolkit import PromptSession
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.completion import NestedCompleter, PathCompleter
from prompt_toolkit.styles import Style

# (ì‚¬ìš©ì ì •ì˜ ëª¨ë“ˆì€ ê·¸ëŒ€ë¡œ ìœ ì§€)
from .actions import DigestActions
from .config_manager import ConfigManager
from .git_ops import is_git_repo

class InteractiveShell:
    def __init__(self, initial_path: Path):
        self.config_manager = ConfigManager()
        self.root_path = initial_path.resolve()

        # ì‹œì‘ ì‹œ í”„ë¡œì„¸ìŠ¤ ê²½ë¡œ ë™ê¸°í™”
        try:
            os.chdir(self.root_path)
        except OSError:
            pass

        self.actions = DigestActions(self.root_path)
        self.config_manager.set_last_project_root(str(self.root_path))

        self.history = InMemoryHistory()

        self.completer = NestedCompleter.from_nested_dict({
            'cd': PathCompleter(only_directories=True),
            'ls': None,
            'dir': None,     # [ì¶”ê°€] ìë™ì™„ì„± ëª©ë¡ì— dir ì¶”ê°€
            'history': None,
            'pwd': None,
            'scan': PathCompleter(),
            'diff': None,
            'exit': None,
            'quit': None,
            'help': None,
            'clear': None,
        })
        
        self.session = PromptSession(
            completer=self.completer,
            history=self.history
        )

    def start(self):
        print("\nğŸš€ Codigest Shell")
        print(f"ğŸ“‚ Project: {self.root_path}")
        print("ğŸ’¡ Type 'help' for commands. Use '!' for system commands (PowerShell).\n")

        while True:
            try:
                style = Style.from_dict({
                    'path': 'ansicyan bold',
                    'arrow': '#ff0066 bold',
                })

                message = [
                    ('class:path', f"({self.root_path.name}) "),
                    ('class:arrow', "> "),
                ]
                
                cmd_input = self.session.prompt(message, style=style).strip()
                
                if not cmd_input:
                    continue

                # '!'ë¡œ ì‹œì‘í•˜ë©´ ì‹œìŠ¤í…œ ëª…ë ¹ì–´ ì‹¤í–‰
                if cmd_input.startswith("!"):
                    self._run_system_command(cmd_input[1:])
                    continue

                parts = shlex.split(cmd_input)
                if not parts:
                    continue
                
                cmd = parts[0].lower()
                args = parts[1:]

                match cmd:
                    case 'exit' | 'quit' | 'q':
                        print("ğŸ‘‹ Bye!")
                        break
                    
                    case 'clear' | 'cls':
                        print("\033[H\033[J", end="")

                    case 'help' | 'h' | '?':
                        self._show_help()

                    case 'pwd':
                        print(f"{self.root_path}")
                    
                    # lsì™€ dirì„ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
                    case 'ls' | 'dir':
                        self._do_ls(args)

                    case 'history':
                        self._do_history()

                    case 'cd':
                        self._do_cd(args)

                    case 'scan':
                        self._do_scan(args)

                    case 'diff':
                        self._do_diff()

                    case _:
                        print(f"â“ Unknown command: {cmd}")

            except KeyboardInterrupt:
                continue
            except EOFError:
                print("\nğŸ‘‹ Bye!")
                sys.exit(0)
            except Exception as e:
                print(f"âŒ Error: {e}")

    def _run_system_command(self, command: str):
        """!ë¡œ ì‹œì‘í•˜ëŠ” ëª…ë ¹ì–´: Windowsë©´ PowerShell, ê·¸ ì™¸ì—” ê¸°ë³¸ Shell"""
        try:
            if os.name == 'nt':
                # [ìˆ˜ì •ë¨] Windowsì¼ ê²½ìš° PowerShell í˜¸ì¶œ
                # ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ë„˜ê¸°ë©´ ì‰˜ ì¸ì ì…˜ ë°©ì§€ì— ì¢‹ê³  ì‹¤í–‰ì´ ëª…í™•í•¨
                subprocess.run(["powershell", "-Command", command], cwd=self.root_path)
            else:
                # Mac/LinuxëŠ” ê¸°ë³¸ ì‰˜ ì‚¬ìš©
                subprocess.run(command, shell=True, cwd=self.root_path)
        except Exception as e:
            print(f"âŒ Execution failed: {e}")

    def _show_help(self):
        print(" Internal Commands:")
        print("  ls / dir        : List directory contents")
        print("  cd <path>       : Change directory")
        print("  pwd             : Print working directory")
        print("  history         : Show command history")
        print("  scan [path]     : Scan project")
        print("  diff            : Copy git diff")
        print("  exit            : Quit")
        print("\n System Commands:")
        print("  !cmd            : Run command in PowerShell (Windows) or Bash (Mac/Linux)")

    def _do_cd(self, args):
        if not args:
            print(f"{self.root_path}")
            return
        
        target = args[0]
        try:
            expanded_path = Path(target).expanduser()
            new_path = (self.root_path / expanded_path).resolve()
        except Exception as e:
            print(f"âŒ Invalid path syntax: {e}")
            return
        
        if new_path.exists() and new_path.is_dir():
            self.root_path = new_path
            self.actions.root_path = new_path
            self.config_manager.set_last_project_root(str(new_path))
            
            # í”„ë¡œì„¸ìŠ¤ CWD ë³€ê²½
            try:
                os.chdir(self.root_path)
            except Exception as e:
                print(f"âš ï¸ Failed to change system CWD: {e}")
        else:
            print(f"The system cannot find the path specified: {target}")

    def _do_ls(self, args):
        """
        ë‚´ì¥ ls/dir ëª…ë ¹ì–´ ì²˜ë¦¬
        ì¸ì(args)ê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
        """
        # ì¸ì ë¦¬ìŠ¤íŠ¸ë¥¼ ë¬¸ìì—´ë¡œ ë³µì›
        # ì˜ˆ: ['-al'] -> ' -al'
        extra_args = " " + " ".join(args) if args else ""
        
        if os.name == 'nt':
            # Windowsì—ì„œëŠ” dir ëª…ë ¹ì–´ ì‹¤í–‰
            # ì£¼ì˜: ì‚¬ìš©ìê°€ 'ls -l'ì„ ì³¤ë”ë¼ë„ ì—¬ê¸°ì„œëŠ” 'dir -l'ë¡œ ì‹¤í–‰ë˜ë¯€ë¡œ
            # Windows dir ëª…ë ¹ì–´ ì˜µì…˜(/w, /p ë“±)ì„ ì¨ì•¼ ì •í™•íˆ ë™ì‘í•©ë‹ˆë‹¤.
            os.system('dir' + extra_args)
        else:
            # Mac/Linux
            os.system('ls --color=auto' + extra_args)

    def _do_history(self):
        history_list = self.history.get_strings()
        for i, cmd in enumerate(history_list):
            print(f"{i + 1}: {cmd}")

    def _do_scan(self, args):
        print("â³ Scanning...", end="\r")
        target_paths = [ (self.root_path / a).resolve() for a in args ] if args else None
        
        result = self.actions.scan(target_paths)
        self._handle_result(result, "Context")

    def _do_diff(self):
        if not is_git_repo(self.root_path):
            print("âŒ Not a git repo.")
            return
        
        print("ğŸ” Checking diff...", end="\r")
        result = self.actions.diff()
        
        if result.startswith("âŒ") or result.startswith("âœ¨"):
            print(result)
        else:
            self._handle_result(result, "Git Diff")

    def _handle_result(self, content: str, label: str):
        try:
            saved_path = self.actions.save_to_file(content)
            print(f"ğŸ’¾ Saved: {saved_path.name}   ", end="")
        except Exception as e:
            print(f"âš ï¸ Save failed: {e}   ", end="")

        if self.actions.copy_to_clipboard(content):
            print(f"ğŸ“‹ Copied {label} to clipboard! ({len(content)} chars)")
        else:
            print("âš ï¸ Clipboard failed.")
</file>

<file path="src/codigest/prompts.py">
INITIAL_PROMPT_TEMPLATE = """
[SYSTEM: CODIGEST - INITIAL CONTEXT]
You are an expert AI developer. I am providing the full context of a project named "{root_name}".
Please digest this structure and code to build your internal mental model.

<project_root>
{root_name}
</project_root>

<project_structure>
{tree_structure}
</project_structure>

<source_code>
{content}
</source_code>
"""

UPDATE_PROMPT_TEMPLATE = """
[SYSTEM: CODIGEST - INCREMENTAL UPDATE]
Here are the latest changes (git diff) since our last sync.
Please update your memory of the codebase accordingly.

<git_diff>
{diff_content}
</git_diff>
"""
</file>
</source_code>
